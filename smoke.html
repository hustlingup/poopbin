<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Blobby Smoke Ball – Fixed Version</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-orbitcontrols@2.110.3/OrbitControls.js"></script>

    <script>
        // ──────────────────────────────────────
        // Scene, Camera, Renderer, Controls
        // ──────────────────────────────────────
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111118);

        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(0, 80, 350);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // ──────────────────────────────────────
        // Lights + Smoke Texture
        // ──────────────────────────────────────
        scene.add(new THREE.AmbientLight(0x404060, 1.5));
        const topLight = new THREE.DirectionalLight(0xaaddff, 1);
        topLight.position.set(200, 300, 200);
        scene.add(topLight);

        const smokeTex = new THREE.TextureLoader().load(
            './public/textures/smoke.png'
        );

        // ──────────────────────────────────────
        // 3D Blobby Ball (shader-based)
        // ──────────────────────────────────────
        const ballGeo = new THREE.IcosahedronGeometry(80, 4);
        const blobbyBall = new THREE.Mesh(ballGeo, new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                colorA: { value: new THREE.Color(0x00ffaa) },
                colorB: { value: new THREE.Color(0x8b4513) }
            },
            vertexShader: `
        varying vec3 vPos;
        uniform float time;
        void main(){
            vPos = position;
            vec3 p = position * (1.0 + 0.15 * sin(time*2.0 + length(position)*0.1));
            gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
        }
    `,
            fragmentShader: `
        varying vec3 vPos;
        uniform vec3 colorA;
        uniform vec3 colorB;
        void main(){
            float mixVal = smoothstep(-80.0,80.0,vPos.y);
            vec3 col = mix(colorB,colorA,mixVal);
            gl_FragColor = vec4(col*0.9, 0.9);
        }
    `,
            transparent: true,
            depthWrite: false
        }));
        scene.add(blobbyBall);

        // ──────────────────────────────────────
        // Smoke Particles – 100 emitters on lower half
        // ──────────────────────────────────────
        const particleCount = 1200;
        const geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const ages = new Float32Array(particleCount);
        const lifetimes = new Float32Array(particleCount);
        const customSizes = new Float32Array(particleCount);
        const colorArray = new Float32Array(particleCount * 3);
        const alphas = new Float32Array(particleCount);

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(colorArray, 3));
        geometry.setAttribute('customSize', new THREE.BufferAttribute(customSizes, 1).setUsage(THREE.DynamicDrawUsage));
        geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1).setUsage(THREE.DynamicDrawUsage));

        const material = new THREE.PointsMaterial({
            map: smokeTex,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true,
            sizeAttenuation: true,
            size: 1.0 // Base, will use customSize
        });

        material.onBeforeCompile = function (shader) {
            shader.vertexShader = `
        attribute float customSize;
        attribute float alpha;
        varying float vAlpha;
        ${shader.vertexShader}
    `.replace(
                `#include <color_vertex>`,
                `#include <color_vertex>
        vAlpha = alpha;`
            ).replace(
                `gl_PointSize = size;`,
                `gl_PointSize = customSize;`
            );
            shader.fragmentShader = `
        varying float vAlpha;
        ${shader.fragmentShader}
    `.replace(
                `gl_FragColor = vec4( color * vColor, opacity );`,
                `gl_FragColor = vec4( color * vColor, opacity * vAlpha );`
            );
        };

        const smoke = new THREE.Points(geometry, material);
        scene.add(smoke);

        // Create 100 emission points biased to the bottom half
        const emitters = [];
        for (let i = 0; i < 100; i++) {
            let phi = Math.acos(2 * Math.random() - 1);
            // Force lower hemisphere
            if (Math.cos(phi) > 0.0) phi = Math.PI - phi;
            const theta = Math.random() * Math.PI * 2;
            const r = 82 + Math.random() * 10;
            emitters.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }

        // Reset / spawn a particle
        function spawn(i) {
            const e = emitters[i % emitters.length];
            positions[i * 3] = e.x;
            positions[i * 3 + 1] = e.y;
            positions[i * 3 + 2] = e.z;

            const normal = e.clone().normalize();
            const tangent = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0, 1, 0)).normalize();
            if (tangent.lengthSq() < 0.01) tangent.set(1, 0, 0);

            const vel = new THREE.Vector3()
                .addScaledVector(tangent, (Math.random() - 0.5) * 20)
                .addScaledVector(normal, 10 + Math.random() * 25)
                .add(new THREE.Vector3(0, 40 + Math.random() * 40, 0)); // strong upward

            velocities[i * 3] = vel.x;
            velocities[i * 3 + 1] = vel.y;
            velocities[i * 3 + 2] = vel.z;

            ages[i] = 0;
            lifetimes[i] = 4 + Math.random() * 5;
            customSizes[i] = 15 + Math.random() * 35;
            alphas[i] = 1.0;

            // Green or brown
            if (Math.random() > 0.5) {
                colorArray[i * 3] = 0.0; colorArray[i * 3 + 1] = 1.0; colorArray[i * 3 + 2] = 0.7;
            } else {
                colorArray[i * 3] = 0.545; colorArray[i * 3 + 1] = 0.27; colorArray[i * 3 + 2] = 0.075;
            }
        }

        // Initial spawn
        for (let i = 0; i < particleCount; i++) spawn(i);

        // ──────────────────────────────────────
        // Animation Loop
        // ──────────────────────────────────────
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.elapsedTime;

            blobbyBall.material.uniforms.time.value = elapsed;
            blobbyBall.rotation.y += delta * 0.05;

            const pos = geometry.getAttribute('position');
            const sizeAttr = geometry.getAttribute('customSize');
            const alphaAttr = geometry.getAttribute('alpha');
            const col = geometry.getAttribute('customColor');

            for (let i = 0; i < particleCount; i++) {
                ages[i] += delta;

                if (ages[i] > lifetimes[i]) {
                    spawn(i);
                    continue;
                }

                const prog = ages[i] / lifetimes[i];

                // Physics
                velocities[i * 3 + 1] += 35 * delta; // buoyancy
                velocities[i * 3] += (Math.sin(elapsed + i * 0.7) * 10 - velocities[i * 3] * 0.4) * delta;
                velocities[i * 3 + 2] += (Math.cos(elapsed + i * 1.1) * 10 - velocities[i * 3 + 2] * 0.4) * delta;

                pos.array[i * 3] += velocities[i * 3] * delta;
                pos.array[i * 3 + 1] += velocities[i * 3 + 1] * delta;
                pos.array[i * 3 + 2] += velocities[i * 3 + 2] * delta;

                // Size & fade
                const s = Math.sin(prog * Math.PI);
                sizeAttr.array[i] = customSizes[i] * (0.5 + s * 1.8);
                alphaAttr.array[i] = 1 - prog;
            }

            pos.needsUpdate = true;
            sizeAttr.needsUpdate = true;
            alphaAttr.needsUpdate = true;
            col.needsUpdate = true;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // ──────────────────────────────────────
        // Resize
        // ──────────────────────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>

</html>